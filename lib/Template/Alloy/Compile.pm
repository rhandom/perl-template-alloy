package CGI::Ex::Template::Compile;

=head1 NAME

CGI::Ex::Template::Compile - Transform CET AST to Perl

=head1 DESCRIPTION

=head1 AUTHOR

Paul Seamons <paul at seamons dot com>

=head1 LICENSE

This module may be distributed under the same terms as Perl itself.

=cut

use strict;
use warnings;
use CGI::Ex::Dump qw(debug);

our $VERSION = '2.13';
our $INDENT  = ' ' x 4;
our $PERL_COMPILE_EXT = '.pl';

###----------------------------------------------------------------###

sub load_perl {
    my ($self, $doc) = @_;

    ### first look for a compiled perl document
    my $perl;
    if ($doc->{'_filename'}) {
        $doc->{'modtime'} ||= (stat $doc->{'_filename'})[9];
        if ($self->{'COMPILE_DIR'} || $self->{'COMPILE_EXT'}) {
            my $file = $doc->{'_filename'};
            $file = $doc->{'COMPILE_DIR'} .'/'. $file if $doc->{'COMPILE_DIR'};
            $file .= $self->{'COMPILE_EXT'} if defined($self->{'COMPILE_EXT'});
            $file .= $PERL_COMPILE_EXT      if defined $PERL_COMPILE_EXT;

            if (-e $file && ($doc->{'_is_str_ref'} || (stat $file)[9] == $doc->{'modtime'})) {
                $perl = $self->slurp($file);
            } else {
                $doc->{'_compile_filename'} = $file;
            }
        }
    }

    $perl ||= $self->compile_template($doc);

    ### save a cache on the fileside as asked
    if ($doc->{'_compile_filename'}) {
        my $dir = $doc->{'_compile_filename'};
        $dir =~ s|/[^/]+$||;
        if (! -d $dir) {
            require File::Path;
            File::Path::mkpath($dir);
        }
        open(my $fh, ">", $doc->{'_compile_filename'}) || $self->throw('compile', "Could not open file \"$doc->{'_compile_filename'}\" for writing: $!");
        ### todo - think about locking
        print $fh $$perl;
        close $fh;
        utime $doc->{'modtime'}, $doc->{'modtime'}, $doc->{'_compile_filename'};
    }

    $perl = eval $$perl;
    $self->throw('compile', "Trouble loading compiled perl: $@") if ! $perl && $@;

    return $perl;
}

sub compile_template {
    my ($self, $doc) = @_;

    local $self->{'_component'} = $doc;
    my $tree = $doc->{'_tree'} ||= $self->load_tree($doc);

    my $str = "# Generated by ".__PACKAGE__." v$VERSION on ".localtime()."\n";
    $str .= "# From file ".($doc->{'_filename'} || $doc->{'name'})."\n\n";
    $str .= "my \$blocks = {};\n";
    $str .= "my \$meta   = {};\n";
    $str .= "my \$code   = sub {\n${INDENT}my (\$self, \$out_ref) = \@_;\n${INDENT}my \$var;\n";

    compile_tree($self, $tree, \$str, $INDENT);

    $str .= "\n${INDENT}return 1;\n};\n\n";

    $str .= "{
${INDENT}blocks => \$blocks,
${INDENT}meta   => \$meta,
${INDENT}code   => \$code,
};\n";
#    print $str;
    return \$str;
}

sub _node_info {
    my ($self, $node, $indent) = @_;
    my $doc = $self->{'_component'} || return '';
    $doc->{'_content'} ||= $self->slurp($doc->{'_filename'});
    my ($line, $char) = $self->get_line_number_by_index($doc, $node->[1], 'include_chars');
    return "\n${indent}# \"$node->[0]\" Line $line char $char (chars $node->[1] to $node->[2])\n";
}

###----------------------------------------------------------------###

sub compile_tree {
    my ($self, $tree, $str_ref, $indent) = @_;

    # node contains (0: DIRECTIVE,
    #                1: start_index,
    #                2: end_index,
    #                3: parsed tag details,
    #                4: sub tree for block types
    #                5: continuation sub trees for sub continuation block types (elsif, else, etc)
    #                6: flag to capture next directive
    my @doc;
    for my $node (@$tree) {

        # text nodes are just the bare text
        if (! ref $node) {
            $node =~ s/\'/\\\'/g;
            $$str_ref .= "${indent}\$\$out_ref .= '$node';\n";
            next;
        }

        $$str_ref .= _node_info($self, $node, $indent);

        # get method to call
        my $directive = $node->[0];
        $directive = 'FILTER' if $directive eq '|';
        next if $directive eq '#';

        my $method = "compile_$directive";
        __PACKAGE__->$method($self, $node, $str_ref, $indent);
    }
}

### takes variables or expressions and translates them
### into the language that compiled TT templates understand
### it will recurse as deep as the expression is deep
### foo                      : 'foo'
### ['foo', 0]               : $stash->get('foo')
### ['foo', 0] = ['bar', 0]  : $stash->set('foo', $stash->get('bar'))
### [[undef, '+', 1, 2], 0]  : do { no warnings; 1 + 2 }
sub compile_expr {
    my ($self, $var, $str_ref, $indent) = @_;

    ### return literals
    if (! ref $var) {
        #if ($val) { # allow for bare literal setting [% 'foo' = 'bar' %]
        #    $var = [$var, 0];
        #} else {
        if ($var =~ /^-?[1-9]\d{0,13}\b(?:|\.0|\.\d{0,13}[1-9])$/) { # return unquoted numbers if it is simple
            $$str_ref .= $var;
        } else {
            $var =~ s/\'/\\\'/g;
            $$str_ref .= "'$var'";  # return quoted items - if they are simple
        }
        return;
        #}
    }

    ### determine the top level of this particular variable access

    my $i = 0;
    my $name = $var->[$i++];
    my $args = $var->[$i++];
    my $is_set  = delete($self->{'_is_set'});
    my $is_bare = delete($self->{'_is_bare'});
    my $open = $is_bare ? '' : $is_set ? '$self->set_variable([' : '$self->play_variable([';

    if (ref $name) {
        if (! defined $name->[0]) { # operator
            if ($i >= @$var && ! $is_set && ! $is_bare) {
                compile_operator($self, $name, $str_ref, $indent);
                return;
            }
            $$str_ref .= '$self->play_expr([' .'[';
            for (0 .. $#$name) {
                if (! defined $name->[$_]) { $$str_ref .= 'undef' }
                else { compile_expr($self, $name->[$_], $str_ref, $indent) }
                $$str_ref .= ', ' if $_ != $#$name;
            }
            $$str_ref .= ']';
        } else { # a named variable access (ie via $name.foo)
            $$str_ref .= $open;
            compile_expr($self, $name, $str_ref, $indent);
        }
    } elsif (defined $name) {
        $$str_ref .= $open;
        if ($self->{'is_namespace_during_compile'}) {
            die;
            #$ref = $self->{'NAMESPACE'}->{$name};
        } else {
            $name =~ s/\'/\\\'/g;
            $$str_ref .= "'$name'";
        }
    } else {
        die "Parsed tree error - found an anomaly" if $is_set || $is_bare;
        $$str_ref .= "''"; # not sure we can get here
    }

    ### add args
    if (! $args) {
        $$str_ref .= ', 0';
    } else {
        $$str_ref .= ', [';
        for (0 .. $#$args) {
            compile_expr($self, $args->[$_], $str_ref, $indent);
            $$str_ref .= ', ' if $_ != $#$args;
        }
        $$str_ref .= ']';
    }

    ### now decent through the other levels
    while ($i < @$var) {
        ### descend one chained level
        $$str_ref .= ", '$var->[$i]'";
        my $was_dot_call = $var->[$i++] eq '.';
        $name            = $var->[$i++];
        $args            = $var->[$i++];

        if (ref $name) {
            if (! defined $name->[0]) { # operator
                die;
                #push @ident, '('. $self->compile_operator($name) .')';
            } else { # a named variable access (ie via $name.foo)
                $$str_ref .= ', ';
                compile_expr($self, $name, $str_ref, $indent);
            }
        } elsif (defined $name) {
            if ($self->{'is_namespace_during_compile'}) {
                die;
                #$ref = $self->{'NAMESPACE'}->{$name};
            } else {
                $name =~ s/\'/\\\'/g;
                $$str_ref .= ", '$name'";
            }
        } else {
            $$str_ref .= "''";
        }

        ### add args
        if (! $args) {
            $$str_ref .= ', 0';
        } else {
            $$str_ref .= ', [';
            for (0 .. $#$args) {
                compile_expr($self, $args->[$_], $str_ref, $indent);
                $$str_ref .= ', ' if $_ != $#$args;
            }
            $$str_ref .= ']';
        }
    }

    $$str_ref .= $is_bare ? '' : $is_set ? '], $var)' : '])';
}

### plays operators
### [[undef, '+', 1, 2], 0]  : do { no warnings; 1 + 2 }
sub compile_operator {
    my ($self, $args, $str_ref, $indent) = @_;
    my (undef, $op, @the_rest) = @$args;
    $op = lc $op;

    $op = ($op eq 'mod') ? '%'
        : ($op eq 'pow') ? '**'
        :                  $op;

    if ($op eq '{}') {
        if (! @the_rest) {
            $$str_ref .= '{}';
            return;
        }
        $$str_ref .= "{\n";
        while (@the_rest) {
            $$str_ref .= "$indent$INDENT";
            compile_expr($self, shift(@the_rest), $str_ref, $indent);
            $$str_ref .= " => ";
            if (@the_rest) {
                compile_expr($self, shift(@the_rest), $str_ref, $indent);
            } else {
                $$str_ref .= "undef";
            }
            $$str_ref .= ",\n";
        }
        $$str_ref .= "}";
        return;
    } elsif ($op eq '[]') {
        $$str_ref .=  "[";
        foreach (0 .. $#the_rest) {
            compile_expr($self, $the_rest[$_], $str_ref, $indent);
            $$str_ref .= ", " if $_ != $#the_rest;
        }
        $$str_ref .= "]";
    } elsif ($op eq '~' || $op eq '_') {
        $$str_ref .=  "do { no warnings; ''";
        foreach (@the_rest) {
            $$str_ref .= ' . ';
            compile_expr($self, $_, $str_ref, $indent);
        }
        $$str_ref .= ' }';
    } elsif ($op eq '=') {
        $$str_ref .= "do {
${indent}${INDENT}my \$var = ";
        compile_expr($self, $the_rest[1], $str_ref, "$indent$INDENT");
        $$str_ref .= ";
${indent}${INDENT}";
        local $self->{'_is_set'} = 1;
        compile_expr($self, $the_rest[0], $str_ref, "$indent$INDENT");
        $$str_ref .= ";
${indent}${INDENT}\$var
${indent}}";

    # handle assignment operators
    } elsif ($CGI::Ex::Template::OP_ASSIGN->{$op}) {
        $op =~ /^([^\w\s\$]+)=$/ || die "Not sure how to handle that op $op";
        my $short = $1;
        $$str_ref .= "do {
${indent}${INDENT}my \$var = ";
        compile_expr($self, [[undef, $short, $the_rest[0], $the_rest[1]], 0], $str_ref, $indent);
        $$str_ref .= ";
${indent}${INDENT}";
        local $self->{'_is_set'} = 1;
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= ";
${indent}${INDENT}\$var;
${indent}}";

    } elsif ($op eq '++') {
        my $is_postfix = $the_rest[1] || 0; # set to 1 during postfix
        $$str_ref .= "do {
${indent}${INDENT}my \$var = ";
        compile_expr($self, [[undef, '+', $the_rest[0], 1], 0], $str_ref, $indent);
        $$str_ref .= ";
${indent}${INDENT}";
        local $self->{'_is_set'} = 1;
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= ";
${indent}${INDENT}$is_postfix ? \$var - 1 : \$var;
${indent}}";

    } elsif ($op eq '--') {
        my $is_postfix = $the_rest[1] || 0; # set to 1 during postfix
        $$str_ref .= "do {
${indent}${INDENT}my \$var = ";
        compile_expr($self, [[undef, '-', $the_rest[0], 1], 0], $str_ref, $indent);
        $$str_ref .= ";
${indent}${INDENT}";
        local $self->{'_is_set'} = 1;
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= ";
${indent}${INDENT}$is_postfix ? \$var + 1 : \$var;
${indent}}";

    } elsif ($op eq 'div' || $op eq 'DIV') {
        $$str_ref .= 'do { no warnings; int(';
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= ' / ';
        compile_expr($self, $the_rest[1], $str_ref, $indent);
        $$str_ref .= ') }';

    } elsif ($op eq '?') {
        $$str_ref .= '(';
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= ' ? ';
        compile_expr($self, $the_rest[1], $str_ref, $indent);
        $$str_ref .= ' : ';
        compile_expr($self, $the_rest[2], $str_ref, $indent);
        $$str_ref .= ')';

    } elsif ($op eq '\\') {
        return do { local $self->{'_return_ref_ident'} = 1; $self->compile_expr($the_rest[0]) };

    } elsif ($op eq 'qr') {
        return $the_rest[1] ? "qr{(?$the_rest[1]:$the_rest[0])}" : "qr{$the_rest[0]}";

    } elsif (@the_rest == 1) {
        $$str_ref .= "do { no warnings; $op";
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= ' }';
    } else {
        $$str_ref .= 'do { no warnings; ';
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= " $op ";
        compile_expr($self, $the_rest[1], $str_ref, $indent);
        $$str_ref .= ' }';
    }
}

###----------------------------------------------------------------###

sub compile_DEFAULT {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    local $self->{'_is_default'} = 1;
    $class->compile_SET($self, $node, $str_ref, $indent);
}

sub compile_DUMP {
    my ($class, $self, $node, $str_ref, $indent) = @_;

    my $dump = $node->[3];
    $$str_ref .= "$indent\$self->play_DUMP([[[undef, '{}'";
    for (2 .. $#{ $dump->[0] }) {
        $$str_ref .= ', ';
        compile_expr($self, $dump->[0]->[$_], $str_ref, $indent);
    }
    $$str_ref .= '], 0]';
    for (1 .. $#$dump) {
        $$str_ref .= ', ';
        compile_expr($self, $dump->[$_], $str_ref, $indent);
    }
    $$str_ref .= "], ['$node->[0]', $node->[1], $node->[2]], \$out_ref);\n";
}

sub compile_GET {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    $$str_ref .= "$indent\$var = ";
    compile_expr($self, $node->[3], $str_ref, $indent);
    $$str_ref .= ";\n";
    $$str_ref .= "$indent\$\$out_ref .= defined(\$var) ? \$var : '';\n"; # TODO - undefined_get
}

sub compile_END {}

sub compile_FILTER {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    my ($name, $filter) = @{ $node->[3] };
    return if ! @$filter;

    my $_filter = '';
    local $self->{'_is_bare'} = 1;
    compile_expr($self, $filter, \$_filter, $indent);

    ### allow for alias
    if (length $name) {
        $name =~ s/\'/\\\'/g;
        $$str_ref .= "$indent\$self->{'FILTERS'}->{'$name'} = [$_filter]; # alias for future calls\n";
    }

    my $temp_name = 'cgi_ex_template_filter_temp';

    $$str_ref .= "${indent}do {
${indent}${INDENT}local \$self->{'_vars'}->{'$temp_name'} = do {
${indent}${INDENT}${INDENT}my \$out = '';
${indent}${INDENT}${INDENT}my \$out_ref = \\\$out;
";

    compile_tree($self, $node->[4], $str_ref, "$indent$INDENT$INDENT");
    $$str_ref .= "
${indent}${INDENT}${INDENT}\$out;
${indent}${INDENT}};

${indent}${INDENT}\$\$out_ref .= \$self->play_variable(['$temp_name', 0, '|', $_filter]);
${indent}};
";

}

sub compile_FOR {
    my ($class, $self, $node, $str_ref, $indent) = @_;

    my ($name, $items) = @{ $node->[3] };

    $$str_ref .= "${indent}do {
${indent}my \$loop = ";
    compile_expr($self, $items, $str_ref, $indent);
    $$str_ref .= ";
${indent}\$loop = [] if ! defined \$loop;
${indent}\$loop = \$self->iterator(\$loop) if ref(\$loop) !~ /Iterator\$/;
${indent}local \$self->{'_vars'}->{'loop'} = \$loop;
";
    if (! defined $name) {
        $$str_ref .= "
${indent}my \$swap = \$self->{'_vars'};
${indent}local \$self->{'_vars'} = my \$copy = {%\$swap};
";
    }

    $$str_ref .= "
${indent}my (\$item, \$error) = \$loop->get_first;
${indent}while (! \$error) {
";

    if (defined $name) {
        $name =~ s/\'/\\\'/g;
        $$str_ref .= "$indent$INDENT\$self->set_variable('$name', \$item);
";
    } else {
        $$str_ref .= "$indent$INDENT\@\$copy{keys %\$item} = values %\$item if ref(\$item) eq 'HASH';
";
    }

    $$str_ref .= "${indent}${INDENT}eval {
";
    compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");
    $$str_ref .= "
${indent}${INDENT}};
${indent}${INDENT}if (my \$err = \$\@) {
${indent}${INDENT}${INDENT}if (UNIVERSAL::can(\$err, 'type')) {
${indent}${INDENT}${INDENT}${INDENT}if (\$err->type eq 'next') {
${indent}${INDENT}${INDENT}${INDENT}${INDENT}(\$item, \$error) = \$loop->get_next;
${indent}${INDENT}${INDENT}${INDENT}${INDENT}next;
${indent}${INDENT}${INDENT}${INDENT}}
${indent}${INDENT}${INDENT}${INDENT}last if \$err->type =~ /last|break/;
${indent}${INDENT}${INDENT}}
${indent}${INDENT}${INDENT}die \$err;
${indent}${INDENT}}

${indent}${INDENT}(\$item, \$error) = \$loop->get_next;
${indent}}
${indent}};
";
    return;
}

sub compile_IF {
    my ($class, $self, $node, $str_ref, $indent, $unless) = @_;

    $$str_ref .= $indent .($unless ? 'unless' : 'if'). ' (';
    compile_expr($self, $node->[3], $str_ref, $indent);
    $$str_ref .= ") {\n";
    compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");

    while ($node = $node->[5]) { # ELSE, ELSIF's
        $$str_ref .= _node_info($self, $node, $indent);
        if ($node->[0] eq 'ELSE') {
            $$str_ref .= "${indent}} else {\n";
            compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");
            last;
        } else {
            $$str_ref .= "${indent}} elsif (";
            compile_expr($self, $node->[3], $str_ref, $indent);
            $$str_ref .= ") {\n";
            compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");
        }
    }
    $$str_ref .= "${indent}}\n";
}

sub compile_LOOP {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    my $ref = $node->[3];
    $ref = [$ref, 0] if ! ref $ref;

    $$str_ref .= "${indent}my \$var = ";
    compile_expr($self, $ref, $str_ref, $indent);
    $$str_ref .= ";
${indent}my \$global = ! \$self->{'SYNTAX'} || \$self->{'SYNTAX'} ne 'ht' || \$self->{'GLOBAL_VARS'};
${indent}my \$items  = ref(\$var) eq 'ARRAY' ? \$var : ref(\$var) eq 'HASH' ? [\$var] : [];

${indent}my \$i = 0;
${indent}for my \$ref (\@\$items) {
${indent}${INDENT}\$self->throw('loop', 'Scalar value used in LOOP') if \$ref && ref(\$ref) ne 'HASH';
${indent}${INDENT}local \$self->{'_vars'} = (! \$global) ? (\$ref || {}) : (ref(\$ref) eq 'HASH') ? {%{ \$self->{'_vars'} }, %\$ref} : \$self->{'_vars'};
${indent}${INDENT}if (\$self->{'LOOP_CONTEXT_VARS'} && ! \$CGI::Ex::Template::QR_PRIVATE) {
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__counter__'} = ++\$i;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__first__'} = \$i == 1 ? 1 : 0;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__last__'}  = \$i == \@\$items ? 1 : 0;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__inner__'} = \$i == 1 || \$i == \@\$items ? 0 : 1;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__odd__'}   = (\$i % 2) ? 1 : 0;
${indent}${INDENT}}
${indent}${INDENT}
${indent}${INDENT}### execute the sub tree
${indent}${INDENT}eval {\n";
    compile_tree($self, $node->[4], $str_ref, "$indent$INDENT$INDENT");
    $$str_ref .="${indent}${INDENT}};
${indent}${INDENT}if (my \$err = \$\@) {
${indent}${INDENT}${INDENT}if (UNIVERSAL::isa(\$err, \$CGI::Ex::Template::PACKAGE_EXCEPTION)) {
${indent}${INDENT}${INDENT}${INDENT}next if \$err->type eq 'next';
${indent}${INDENT}${INDENT}${INDENT}last if \$err->type =~ /last|break/;
${indent}${INDENT}${INDENT}}
${indent}${INDENT}${INDENT}die \$err;
${indent}${INDENT}}
${indent}}\n";
}

sub compile_SET {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    my $sets = $node->[3];

    my $out = '';
    foreach (@$sets) {
        my ($op, $set, $val) = @$_;

        $$str_ref .= "$indent\$var = ";

        if ($CGI::Ex::Template::OP_DISPATCH->{$op}) {
            $op =~ /^([^\w\s\$]+)=$/ || die "Not sure how to handle that op $op during SET";
            my $short = ($1 eq '_' || $1 eq '~') ? '.' : $1;
            $$str_ref .= 'do { no warnings; ';
            compile_expr($self, $set, $str_ref, $indent);
            $$str_ref .= " $short ";
        }

        if (! defined $val) { # not defined
            $$str_ref .= 'undef';
        } elsif ($node->[4] && $val == $node->[4]) { # a captured directive
            die;
            my $sub_tree = $node->[4];
            $sub_tree = $sub_tree->[0]->[4] if $sub_tree->[0] && $sub_tree->[0]->[0] eq 'BLOCK';
            $set = do { local $self->{'_return_capture_ident'} = 1; $self->compile_expr($set) };
            $out .= $self->{'FACTORY'}->capture($set, $self->compile_tree($sub_tree));
            next;
        } else { # normal var
            compile_expr($self, $val, $str_ref, $indent);
        }

        if ($CGI::Ex::Template::OP_DISPATCH->{$op}) {
            $$str_ref .= ' }';
        }
        $$str_ref .= ";\n$indent";

        local $self->{'_is_set'} = 1;
        compile_expr($self, $set, $str_ref, $indent);

        if ($self->{'_is_default'}) {
            delete $self->{'_is_set'};
            $$str_ref .= ' if ! ';
            compile_expr($self, $set, $str_ref, $indent);
        }

        $$str_ref .= ";\n";
    }

    return $out;
}

###----------------------------------------------------------------###

1;
