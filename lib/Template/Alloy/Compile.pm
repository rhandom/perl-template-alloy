package CGI::Ex::Template::Compile;

=head1 NAME

CGI::Ex::Template::Compile - Transform CET AST to Perl

=head1 DESCRIPTION

=head1 AUTHOR

Paul Seamons <paul at seamons dot com>

=head1 LICENSE

This module may be distributed under the same terms as Perl itself.

=cut

use strict;
use warnings;
use CGI::Ex::Dump qw(debug);

our $VERSION = '2.13';
our $INDENT  = ' ' x 4;
our $PERL_COMPILE_EXT = '.pl';

###----------------------------------------------------------------###

sub load_perl {
    my ($self, $doc) = @_;

    ### first look for a compiled perl document
    my $perl;
    if ($doc->{'_filename'}) {
        $doc->{'modtime'} ||= (stat $doc->{'_filename'})[9];
        if ($self->{'COMPILE_DIR'} || $self->{'COMPILE_EXT'}) {
            my $file = $doc->{'_filename'};
            $file = $doc->{'COMPILE_DIR'} .'/'. $file if $doc->{'COMPILE_DIR'};
            $file .= $self->{'COMPILE_EXT'} if defined($self->{'COMPILE_EXT'});
            $file .= $PERL_COMPILE_EXT      if defined $PERL_COMPILE_EXT;

            if (-e $file && ($doc->{'_is_str_ref'} || (stat $file)[9] == $doc->{'modtime'})) {
                $perl = $self->slurp($doc->{'_filename'});
            } else {
                $doc->{'_compile_filename'} = $file;
            }
        }
    }

    if (! $perl) {
        $perl = $self->compile_template($doc);
    }

    ### save a cache on the fileside as asked
    if ($doc->{'_compile_filename'}) {
        my $dir = $doc->{'_compile_filename'};
        $dir =~ s|/[^/]+$||;
        if (! -d $dir) {
            require File::Path;
            File::Path::mkpath($dir);
        }
        open(my $fh, ">", $doc->{'_compile_filename'}) || $self->throw('compile', "Could not open file \"$doc->{'_compile_filename'}\" for writing: $!");
        ### todo - think about locking
        print $fh $$perl;
        close $fh;
        utime $doc->{'modtime'}, $doc->{'modtime'}, $doc->{'_compile_filename'};
    }

    return eval $$perl;
}

sub compile_template {
    my ($self, $doc) = @_;

    local $self->{'_component'} = $doc;
    my $tree = $doc->{'_tree'} ||= $self->load_tree($doc);

    my $str = "# Generated by ".__PACKAGE__." v$VERSION on ".localtime()."\n";
    $str .= "# From file ".($doc->{'_filename'} || $doc->{'name'})."\n";
    $str .= "my \$blocks = {};\n";
    $str .= "my \$meta   = {};\n";
    $str .= "my \$code = sub {\n${INDENT}my (\$self, \$out_ref) = \@_;\n";

    compile_tree($self, $tree, \$str, $INDENT);

    $str .= "${INDENT}return 1;\n};\n";

    $str .= "{
${INDENT}blocks => \$blocks,
${INDENT}meta   => \$meta,
${INDENT}code => \$code,
};\n";
#    print $str;
    return \$str;
}

sub _node_info {
    my ($self, $node, $indent) = @_;
    my $doc = $self->{'_component'} || return '';
    $doc->{'_content'} ||= $self->slurp($doc->{'_filename'});
    my ($line, $char) = $self->get_line_number_by_index($doc, $node->[1], 'include_chars');
    return "\n${indent}# \"$node->[0]\" Line $line char $char (chars $node->[1] to $node->[2])\n";
}

###----------------------------------------------------------------###

sub compile_tree {
    my ($self, $tree, $str_ref, $indent) = @_;

    # node contains (0: DIRECTIVE,
    #                1: start_index,
    #                2: end_index,
    #                3: parsed tag details,
    #                4: sub tree for block types
    #                5: continuation sub trees for sub continuation block types (elsif, else, etc)
    #                6: flag to capture next directive
    my @doc;
    for my $node (@$tree) {

        # text nodes are just the bare text
        if (! ref $node) {
            $node =~ s/\'/\\\'/g;
            $$str_ref .= "${indent}\$\$out_ref .= '$node';\n";
            next;
        }

        $$str_ref .= _node_info($self, $node, $indent);

        # get method to call
        my $directive = $node->[0];
        $directive = 'FILTER' if $directive eq '|';
        next if $directive eq '#';

        my $method = "compile_$directive";
        __PACKAGE__->$method($self, $node, $str_ref, $indent);
    }
}

### takes variables or expressions and translates them
### into the language that compiled TT templates understand
### it will recurse as deep as the expression is deep
### foo                      : 'foo'
### ['foo', 0]               : $stash->get('foo')
### ['foo', 0] = ['bar', 0]  : $stash->set('foo', $stash->get('bar'))
### [[undef, '+', 1, 2], 0]  : do { no warnings; 1 + 2 }
sub compile_expr {
    my ($self, $var, $str_ref, $indent) = @_;

    ### return literals
    if (! ref $var) {
        #if ($val) { # allow for bare literal setting [% 'foo' = 'bar' %]
        #    $var = [$var, 0];
        #} else {
        if ($var =~ /^-?[1-9]\d{0,13}\b(?:|\.0|\.\d{0,13}[1-9])$/) { # return unquoted numbers if it is simple
            $$str_ref .= $var;
        } else {
            $var =~ s/\'/\\\'/g;
            $$str_ref .= "'$var'";  # return quoted items - if they are simple
        }
        return;
        #}
    }

    ### determine the top level of this particular variable access

    my $i = 0;
    my $name = $var->[$i++];
    my $args = $var->[$i++];
    my $is_set = delete($self->{'_is_set'});
    my $open = $is_set ? '$self->set_variable([' : '$self->play_expr([';

    if (ref $name) {
        if (! defined $name->[0]) { # operator
            if ($i >= @$var && ! $is_set) {
                compile_operator($self, $name, $str_ref, $indent);
                return;
            }
            $$str_ref .= '$self->play_expr([';
            for (0 .. $#$name) {
                if (! defined $name->[$_]) { $$str_ref .= 'undef' }
                else { compile_expr($self, $name->[$_], $str_ref, $indent) }
                $$str_ref .= ', ';
            }
            $$str_ref .= ']';
        } else { # a named variable access (ie via $name.foo)
            $$str_ref .= '$self->play_expr([';
            compile_expr($self, $name, $str_ref, $indent);
        }
    } elsif (defined $name) {
        $$str_ref .= '$self->play_expr([';
        if ($self->{'is_namespace_during_compile'}) {
            die;
            #$ref = $self->{'NAMESPACE'}->{$name};
        } else {
            $name =~ s/\'/\\\'/g;
            $$str_ref .= "'$name'";
        }
    } else {
        $$str_ref .= "''"; # not sure we can get here
    }

    ### add args
    if (! $args) {
        $$str_ref .= ', 0';
    } else {
        $$str_ref .= ', [';
        for my $var (@$args) {
            compile_expr($self, $var, $str_ref, $indent);
            $$str_ref .= ', ';
        }
        $$str_ref .= ']';
    }

    ### now decent through the other levels
    while ($i < @$var) {
        ### descend one chained level
        $$str_ref .= ", '$var->[$i]'";
        my $was_dot_call = $var->[$i++] eq '.';
        $name            = $var->[$i++];
        $args            = $var->[$i++];

        if (ref $name) {
            if (! defined $name->[0]) { # operator
                die;
                #push @ident, '('. $self->compile_operator($name) .')';
            } else { # a named variable access (ie via $name.foo)
                $$str_ref .= ', ';
                compile_expr($self, $name, $str_ref, $indent);
            }
        } elsif (defined $name) {
            if ($self->{'is_namespace_during_compile'}) {
                die;
                #$ref = $self->{'NAMESPACE'}->{$name};
            } else {
                $name =~ s/\'/\\\'/g;
                $$str_ref .= ", '$name'";
            }
        } else {
            $$str_ref .= "''";
        }

        ### add args
        if (! $args) {
            $$str_ref .= ', 0';
        } else {
            $$str_ref .= ', [';
            for (@$args) {
                compile_expr($self, $_, $str_ref, $indent);
                $$str_ref .= ', ';
            }
            $$str_ref .= ']';
        }
    }

    $$str_ref .= '])';
}

### plays operators
### [[undef, '+', 1, 2], 0]  : do { no warnings; 1 + 2 }
sub compile_operator {
    my ($self, $args, $str_ref, $indent) = @_;
    my (undef, $op, @the_rest) = @$args;
    $op = lc $op;

    $op = ($op eq 'mod') ? '%'
        : ($op eq 'pow') ? '**'
        :                  $op;

    if ($op eq '{}') {
        if (! @the_rest) {
            $$str_ref .= '{}';
            return;
        }
        $$str_ref .= "{\n";
        while (@the_rest) {
            $$str_ref .= "$indent$INDENT";
            compile_expr($self, shift(@the_rest), $str_ref, $indent);
            $$str_ref .= " => ";
            if (@the_rest) {
                compile_expr($self, shift(@the_rest), $str_ref, $indent);
            } else {
                $$str_ref .= "undef";
            }
            $$str_ref .= ",\n";
        }
        $$str_ref .= "}";
        return;
    } elsif ($op eq '[]') {
        $$str_ref .=  "[";
        foreach (@the_rest) {
            compile_expr($self, $_, $str_ref, $indent);
            $$str_ref .= ",";
        }
        $$str_ref .= "]";
    } elsif ($op eq '~' || $op eq '_') {
        $$str_ref .=  "(''.";
        foreach (@the_rest) {
            compile_expr($self, $_, $str_ref, $indent);
            $$str_ref .= ".''";
        }
        $$str_ref .= ")";
    } elsif ($op eq '=') {
        return $self->compile_expr($the_rest[0], $self->compile_expr($the_rest[1]));

    # handle assignment operators
    } elsif ($CGI::Ex::Template::OP_ASSIGN->{$op}) {
        $op =~ /^([^\w\s\$]+)=$/ || die "Not sure how to handle that op $op";
        my $short = ($1 eq '_' || $1 eq '~') ? '.' : $1;
        die;
        return $self->compile_expr($the_rest[0], "do { no warnings; "
                                   .$self->compile_expr($the_rest[0]) ." $short ". $self->compile_expr($the_rest[1]) ."; }");

    } elsif ($op eq '++') {
        my $is_postfix = $the_rest[1] || 0; # set to 1 during postfix
        die;
        return "do { no warnings;\nmy \$val = 0 + ".$self->compile_expr($the_rest[0]).";\n"
            .$self->compile_expr($the_rest[0], "\$val + 1").";\n"
            ."$is_postfix ? \$val : \$val + 1;\n}";

    } elsif ($op eq '--') {
        my $is_postfix = $the_rest[1] || 0; # set to 1 during postfix
        die;
        return "do { no warnings;\nmy \$val = 0 + ".$self->compile_expr($the_rest[0]).";\n"
            .$self->compile_expr($the_rest[0], "\$val - 1").";\n"
            ."$is_postfix ? \$val : \$val - 1;\n}";

    } elsif ($op eq 'div' || $op eq 'DIV') {
        return "do { no warnings;\n int(".$self->compile_expr($the_rest[0])." / ".$self->compile_expr($the_rest[1]).")}";

    } elsif ($op eq '?') {
        return "(" .$self->compile_expr($the_rest[0])
            ." ? ".$self->compile_expr($the_rest[1])
            ." : ".$self->compile_expr($the_rest[2]).")";

    } elsif ($op eq '\\') {
        return do { local $self->{'_return_ref_ident'} = 1; $self->compile_expr($the_rest[0]) };

    } elsif ($op eq 'qr') {
        return $the_rest[1] ? "qr{(?$the_rest[1]:$the_rest[0])}" : "qr{$the_rest[0]}";

    } elsif (@the_rest == 1) {
        $$str_ref .= 'do { no warnings; $op';
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= ' }';
    } else {
        $$str_ref .= 'do { no warnings; ';
        compile_expr($self, $the_rest[0], $str_ref, $indent);
        $$str_ref .= " $op ";
        compile_expr($self, $the_rest[1], $str_ref, $indent);
        $$str_ref .= ' }';
    }
}

###----------------------------------------------------------------###

sub compile_GET {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    $$str_ref .= "${indent}\$\$out_ref .= ";
    compile_expr($self, $node->[3], $str_ref, $indent);
    $$str_ref .= ";\n";
}

sub compile_IF {
    my ($class, $self, $node, $str_ref, $indent, $unless) = @_;

    $$str_ref .= $indent .($unless ? 'unless' : 'if'). ' (';
    compile_expr($self, $node->[3], $str_ref, $indent);
    $$str_ref .= ") {\n";
    compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");

    while ($node = $node->[5]) { # ELSE, ELSIF's
        $$str_ref .= _node_info($self, $node, $indent);
        if ($node->[0] eq 'ELSE') {
            $$str_ref .= "${indent}} else {\n";
            compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");
            last;
        } else {
            $$str_ref .= "${indent}} elsif (";
            compile_expr($self, $node->[3], $str_ref, $indent);
            $$str_ref .= ") {\n";
            compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");
        }
    }
    $$str_ref .= "${indent}}\n";
}

sub compile_END {}

sub compile_LOOP {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    my $ref = $node->[3];
    $ref = [$ref, 0] if ! ref $ref;

    $$str_ref .= "${indent}my \$var = ";
    compile_expr($self, $ref, $str_ref, $indent);
    $$str_ref .= ";
${indent}my \$global = ! \$self->{'SYNTAX'} || \$self->{'SYNTAX'} ne 'ht' || \$self->{'GLOBAL_VARS'};
${indent}my \$items  = ref(\$var) eq 'ARRAY' ? \$var : ref(\$var) eq 'HASH' ? [\$var] : [];

${indent}my \$i = 0;
${indent}for my \$ref (\@\$items) {
${indent}${INDENT}\$self->throw('loop', 'Scalar value used in LOOP') if \$ref && ref(\$ref) ne 'HASH';
${indent}${INDENT}local \$self->{'_vars'} = (! \$global) ? (\$ref || {}) : (ref(\$ref) eq 'HASH') ? {%{ \$self->{'_vars'} }, %\$ref} : \$self->{'_vars'};
${indent}${INDENT}if (\$self->{'LOOP_CONTEXT_VARS'} && ! \$CGI::Ex::Template::QR_PRIVATE) {
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__counter__'} = ++\$i;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__first__'} = \$i == 1 ? 1 : 0;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__last__'}  = \$i == \@\$items ? 1 : 0;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__inner__'} = \$i == 1 || \$i == \@\$items ? 0 : 1;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__odd__'}   = (\$i % 2) ? 1 : 0;
${indent}${INDENT}}
${indent}${INDENT}
${indent}${INDENT}### execute the sub tree
${indent}${INDENT}eval {\n";
    compile_tree($self, $node->[4], $str_ref, "$indent$INDENT$INDENT");
    $$str_ref .="${indent}${INDENT}};
${indent}${INDENT}if (my \$err = \$\@) {
${indent}${INDENT}${INDENT}if (UNIVERSAL::isa(\$err, \$CGI::Ex::Template::PACKAGE_EXCEPTION)) {
${indent}${INDENT}${INDENT}${INDENT}next if \$err->type eq 'next';
${indent}${INDENT}${INDENT}${INDENT}last if \$err->type =~ /last|break/;
${indent}${INDENT}${INDENT}}
${indent}${INDENT}${INDENT}die \$err;
${indent}${INDENT}}
${indent}}\n";
}

1;
