package CGI::Ex::Template::Compile;

=head1 NAME

CGI::Ex::Template::Compile - Transform CET AST to Perl

=head1 DESCRIPTION

=head1 AUTHOR

Paul Seamons <paul at seamons dot com>

=head1 LICENSE

This module may be distributed under the same terms as Perl itself.

=cut

use strict;
use warnings;
use CGI::Ex::Dump qw(debug);

our $VERSION = '2.13';
our $INDENT  = ' ' x 4;

###----------------------------------------------------------------###

sub load_perl {
    my ($self, $doc) = @_;

    my $str = '# generated by '.__PACKAGE__.' at '.localtime()."\n";
    $str .= "sub {\n${INDENT}my (\$self, \$out_ref) = \@_;\n";

    compile_tree($self, $doc->{'_tree'}, \$str, $INDENT);

    $str .= "${INDENT}return 1;\n};\n";
    print $str;
    return eval $str;
}

sub compile_tree {
    my ($self, $tree, $str_ref, $indent) = @_;

    # node contains (0: DIRECTIVE,
    #                1: start_index,
    #                2: end_index,
    #                3: parsed tag details,
    #                4: sub tree for block types
    #                5: continuation sub trees for sub continuation block types (elsif, else, etc)
    #                6: flag to capture next directive
    my @doc;
    for my $node (@$tree) {

        # text nodes are just the bare text
        if (! ref $node) {
            $node =~ s/\'/\\\'/g;
            $$str_ref .= "${indent}\$\$out_ref .= '$node';\n";
            next;
        }

        $$str_ref .= "\n${indent}# \"$node->[0]\" chars $node->[1] to $node->[2]\n";

        # get method to call
        my $directive = $node->[0];
        $directive = 'FILTER' if $directive eq '|';
        next if $directive eq '#';

        my $method = "compile_$directive";
        __PACKAGE__->$method($self, $node, $str_ref, $indent);
    }
}

### takes variables or expressions and translates them
### into the language that compiled TT templates understand
### it will recurse as deep as the expression is deep
### foo                      : 'foo'
### ['foo', 0]               : $stash->get('foo')
### ['foo', 0] = ['bar', 0]  : $stash->set('foo', $stash->get('bar'))
### [[undef, '+', 1, 2], 0]  : do { no warnings; 1 + 2 }
sub compile_expr {
    my ($self, $var, $str_ref, $indent) = @_;

    ### return literals
    if (! ref $var) {
        #if ($val) { # allow for bare literal setting [% 'foo' = 'bar' %]
        #    $var = [$var, 0];
        #} else {
        if ($var =~ /^-?[1-9]\d{0,13}\b(?:|\.0|\.\d{0,13}[1-9])$/) { # return unquoted numbers if it is simple
            $$str_ref .= $var;
        } else {
            $var =~ s/\'/\\\'/g;
            $$str_ref .= "'$var'";  # return quoted items - if they are simple
        }
        return;
        #}
    }

    ### determine the top level of this particular variable access
    $$str_ref .= '$self->play_expr([';
    my $i = 0;
    my $name = $var->[$i++];
    my $args = $var->[$i++];
    my $use_temp_varname;
    if (ref $name) {
        if (! defined $name->[0]) { # operator
            die;
            my $op_val = '('. $self->compile_operator($name) .')';
            return $op_val if $i >= @$var;
            #$use_temp_varname = "do {\n  ".$self->{'FACTORY'}->assign(["'$TEMP_VARNAME'", 0], $op_val).";\n  ";
            #push @ident, "'$TEMP_VARNAME'";
        } else { # a named variable access (ie via $name.foo)
            compile_expr($self, $name, $str_ref, $indent);
        }
    } elsif (defined $name) {
        if ($self->{'is_namespace_during_compile'}) {
            die;
            #$ref = $self->{'NAMESPACE'}->{$name};
        } else {
            $name =~ s/\'/\\\'/g;
            $$str_ref .= "'$name'";
        }
    } else {
        $$str_ref .= "''"; # not sure we can get here
    }

    ### add args
    if (! $args) {
        $$str_ref .= ', 0';
    } else {
        $$str_ref .= ', [';
        for my $var (@$args) {
            compile_expr($self, $var, $str_ref, $indent);
            $$str_ref .= ', ';
        }
        $$str_ref .= ']';
    }

    ### now decent through the other levels
    while ($i < @$var) {
        ### descend one chained level
        $$str_ref .= ", '$var->[$i]'";
        my $was_dot_call = $var->[$i++] eq '.';
        $name            = $var->[$i++];
        $args            = $var->[$i++];

        if (ref $name) {
            if (! defined $name->[0]) { # operator
                die;
                #push @ident, '('. $self->compile_operator($name) .')';
            } else { # a named variable access (ie via $name.foo)
                $$str_ref .= ', ';
                compile_expr($self, $name, $str_ref, $indent);
            }
        } elsif (defined $name) {
            if ($self->{'is_namespace_during_compile'}) {
                die;
                #$ref = $self->{'NAMESPACE'}->{$name};
            } else {
                $name =~ s/\'/\\\'/g;
                $$str_ref .= ", '$name'";
            }
        } else {
            $$str_ref .= "''";
        }

        ### add args
        if (! $args) {
            $$str_ref .= ', 0';
        } else {
            $$str_ref .= ', [';
            for (@$args) {
                compile_expr($self, $_, $str_ref, $indent);
                $$str_ref .= ', ';
            }
            $$str_ref .= ']';
        }
    }

    $$str_ref .= '])';
}

###----------------------------------------------------------------###

sub compile_GET {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    $$str_ref .= "${indent}\$\$out_ref .= ";
    compile_expr($self, $node->[3], $str_ref, $indent);
    $$str_ref .= ";\n";
}

sub compile_IF {
    my ($class, $self, $node, $str_ref, $indent, $unless) = @_;

    $$str_ref .= $indent .($unless ? 'unless' : 'if'). ' (';
    compile_expr($self, $node->[3], $str_ref, $indent);
    $$str_ref .= ") {\n";
    compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");

    while ($node = $node->[5]) { # ELSE, ELSIF's
        $$str_ref .= "\n${indent}# \"$node->[0]\" chars $node->[1] to $node->[2]\n";
        if ($node->[0] eq 'ELSE') {
            $$str_ref .= "${indent}} else {\n";
            compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");
            last;
        } else {
            $$str_ref .= "${indent}} elsif (";
            compile_expr($self, $node->[3], $str_ref, $indent);
            $$str_ref .= ") {\n";
            compile_tree($self, $node->[4], $str_ref, "$indent$INDENT");
        }
    }
    $$str_ref .= "${indent}}\n";
}

sub compile_END {}

sub compile_LOOP {
    my ($class, $self, $node, $str_ref, $indent) = @_;
    my $ref = $node->[3];
    $ref = [$ref, 0] if ! ref $ref;

    $$str_ref .= "${indent}my \$var = ";
    compile_expr($self, $ref, $str_ref, $indent);
    $$str_ref .= ";
${indent}my \$global = ! \$self->{'SYNTAX'} || \$self->{'SYNTAX'} ne 'ht' || \$self->{'GLOBAL_VARS'};
${indent}my \$items  = ref(\$var) eq 'ARRAY' ? \$var : ref(\$var) eq 'HASH' ? [\$var] : [];

${indent}my \$i = 0;
${indent}for my \$ref (\@\$items) {
${indent}${INDENT}\$self->throw('loop', 'Scalar value used in LOOP') if \$ref && ref(\$ref) ne 'HASH';
${indent}${INDENT}local \$self->{'_vars'} = (! \$global) ? (\$ref || {}) : (ref(\$ref) eq 'HASH') ? {%{ \$self->{'_vars'} }, %\$ref} : \$self->{'_vars'};
${indent}${INDENT}if (\$self->{'LOOP_CONTEXT_VARS'} && ! \$CGI::Ex::Template::QR_PRIVATE) {
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__counter__'} = ++\$i;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__first__'} = \$i == 1 ? 1 : 0;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__last__'}  = \$i == \@\$items ? 1 : 0;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__inner__'} = \$i == 1 || \$i == \@\$items ? 0 : 1;
${indent}${INDENT}${INDENT}\$self->{'_vars'}->{'__odd__'}   = (\$i % 2) ? 1 : 0;
${indent}${INDENT}}
${indent}${INDENT}
${indent}${INDENT}### execute the sub tree
${indent}${INDENT}eval {\n";
    compile_tree($self, $node->[4], $str_ref, "$indent$INDENT$INDENT");
    $$str_ref .="${indent}${INDENT}};
${indent}${INDENT}if (my \$err = \$\@) {
${indent}${INDENT}${INDENT}if (UNIVERSAL::isa(\$err, \$CGI::Ex::Template::PACKAGE_EXCEPTION)) {
${indent}${INDENT}${INDENT}${INDENT}next if \$err->type eq 'next';
${indent}${INDENT}${INDENT}${INDENT}last if \$err->type =~ /last|break/;
${indent}${INDENT}${INDENT}}
${indent}${INDENT}${INDENT}die \$err;
${indent}${INDENT}}
${indent}}\n";
}

1;
